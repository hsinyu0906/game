# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RxbZ0LhAY5LuMtIDjAhB8OJP_6-R4jaN
"""

import pandas as pd

# 定義處理步驟的函式
def process_data(df):
    # 選擇 team 欄位中值為 1 的資料
    # df_team1 = df[df['team'] == 1]

    # 取得所有包含 team1 的比賽
    selected_games = df['game'].unique()

    # 選擇包含 selected_games 中的比賽紀錄
    filtered_df = df[df['game'].isin(selected_games) | df['game'].isin(selected_games)]

    return filtered_df

# 讀取三個檔案，並進行相同的處理步驟
files = ['teamsgame15.csv', 'teamsgame16.csv', 'teamsgame17.csv', 'teamsgame18.csv']
dfs = []

for file in files:
    df = pd.read_csv(file, encoding='big5')
    processed_df = process_data(df)
    # 獲取年份
    year = int(file[9:11])  # 假設檔案名稱格式為 'teamsgameYY.csv'
    # 新增 'year' 欄位
    processed_df['year'] = year
    dfs.append(processed_df)

# 合併處理完的數據
combined_df = pd.concat(dfs)

# 儲存合併後的結果為新的 CSV 檔案
combined_df

import pandas as pd

# 讀取數據集並根據日期和比賽編號進行排序
games_df = combined_df
games_df = games_df.sort_values(by=['date', 'game'], ascending=[True, True])

# 新增一個欄位 winner，比較兩個隊伍的分數決定勝負
games_df['winner'] = (games_df.groupby(['date', 'game'])['score']
                      .transform(lambda x: (x == x.max()).astype(int)))

print(games_df)

# ...
# 其他導入和初始化代碼...

# 建立一個新的列來結合date和game
games_df['unique_game'] = games_df['date'].astype(str) + '_' + games_df['game'].astype(str)

# 使用unique_game代替之前的'game'進行後續分析
games_df = games_df.sort_values(by=['unique_game', 'score'], ascending=[True, False])
games_df['winner'] = games_df.groupby('unique_game')['score'].diff().lt(0).astype(int)

# 接下來，我們需要按照`unique_game`更新所有的groupby操作，而不是'game'
games_df['team_avg_score'] = games_df.groupby('team')['total'].transform('mean')
games_df['team_wins'] = games_df.groupby('team')['winner'].transform(lambda x: (x == 0).sum())
games_df['team_losses'] = games_df.groupby('team')['winner'].transform(lambda x: (x == 1).sum())
games_df['team_games'] = games_df['team_wins'] + games_df['team_losses']
games_df['team_win_rate'] = games_df['team_wins'] / games_df['team_games']

# 然後，基於上述更新，您可以繼續其他的預處理、模型訓練和評估等步驟...

games_df.head(10)

import pandas as pd

# 假設你的文件名列表
file_names = ['player15.csv', 'player16.csv', 'player17.csv','player18.csv']

# Similar transformations as in your previous code
weights = {
    1: {'attack_rate': 0.2, 'block_rate': 0.2, 'serve_rate': 0.2, 'receive_rate': 0.3, 'dig_rate': 0.1, 'set_rate': 0.0},
    2: {'attack_rate': 0.4, 'block_rate': 0.2, 'serve_rate': 0.2, 'receive_rate': 0.1, 'dig_rate': 0.1, 'set_rate': 0.0},
    3: {'attack_rate': 0.3, 'block_rate': 0.2, 'serve_rate': 0.2, 'receive_rate': 0.1, 'dig_rate': 0.1, 'set_rate': 0.1},
    4: {'attack_rate': 0.1, 'block_rate': 0.1, 'serve_rate': 0.1, 'receive_rate': 0.1, 'dig_rate': 0.1, 'set_rate': 0.5},
    5: {'attack_rate': 0.3, 'block_rate': 0.4, 'serve_rate': 0.1, 'receive_rate': 0.1, 'dig_rate': 0.1, 'set_rate': 0.0},
}

processed_dfs = []


for file_name in file_names:
    # 讀取文件
    player_df = pd.read_csv(file_name, encoding='big5')
    player_df['year'] = year
    # Extract year from file name
    year = int(file_name[6:8])


    # Calculate score rates
    player_df['attack_rate'] = player_df['attack_score'] / player_df['attack_total']
    player_df['block_rate'] = player_df['block_score'] / player_df['block_total']
    player_df['serve_rate'] = player_df['serve_score'] / player_df['serve_total']
    player_df['receive_rate'] = player_df['receive_nice'] / player_df['receive_total']
    player_df['dig_rate'] = player_df['dig_nice'] / player_df['dig_total']
    player_df['set_rate'] = player_df['set_nice'] / player_df['set_total']

    # Fill NaN values
    for col in ['attack_rate', 'block_rate', 'serve_rate', 'receive_rate', 'dig_rate', 'set_rate']:
        player_df[col].fillna(player_df[col].mean(), inplace=True)

    # Apply weights
    for pos in weights:
        for column in weights[pos]:
            player_df.loc[player_df['position'] == pos, column] *= weights[pos][column]

    # 保存處理後的數據
    processed_dfs.append(player_df)

# 合併處理完的數據
combined_df = pd.concat(processed_dfs)

player_df = combined_df
player_df

unique_names = player_df['name'].nunique()
print(f"Number of unique names: {unique_names}")

# Aggregate player statistics by team
player_features = ['team', 'attack_rate', 'block_rate', 'serve_rate', 'receive_rate', 'dig_rate', 'set_rate']
player_df = player_df.groupby('team').agg({
    'attack_rate': 'mean',
    'block_rate': 'mean',
    'serve_rate': 'mean',
    'receive_rate': 'mean',
    'dig_rate': 'mean',
    'set_rate': 'mean',
}).reset_index()

# Merge player_df and games_df on 'team'
final_df = games_df.merge(player_df, on='team')

# You might want to drop some unnecessary columns before training
final_df.drop(columns=['team1'], inplace=True)

# Sort by 'game'
final_df = final_df.sort_values(by=['unique_game'])
final_df

import numpy as np
import matplotlib.pyplot as plt
from keras.models import Sequential
from keras.layers import LSTM, Dense
from sklearn.preprocessing import MinMaxScaler
from keras.layers import Dropout
from sklearn.model_selection import train_test_split

# 1. 數據預處理
features = ['attack_rate', 'block_rate', 'serve_rate', 'receive_rate', 'dig_rate', 'set_rate','team_wins','team_losses']

# 假設你有一個完整的數據集 final_df
# 使用85%的數據作為訓練集，15%作為測試集
train_df, test_df = train_test_split(final_df, test_size=0.15, random_state=42)

# 分割特征和目標
X_train = train_df[features].values
y_train = train_df['winner'].values
X_test = test_df[features].values
y_test = test_df['winner'].values

# 歸一化
scaler = MinMaxScaler(feature_range=(0, 1))
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# 根據LSTM的輸入格式重塑資料
time_steps = 5

X_train_lstm = []
y_train_lstm = []
for i in range(time_steps, len(X_train)):
    X_train_lstm.append(X_train[i - time_steps:i])
    y_train_lstm.append(y_train[i])
X_train_lstm, y_train_lstm = np.array(X_train_lstm), np.array(y_train_lstm)

X_test_lstm = []
y_test_lstm = []
for i in range(time_steps, len(X_test)):
    X_test_lstm.append(X_test[i - time_steps:i])
    y_test_lstm.append(y_test[i])
X_test_lstm, y_test_lstm = np.array(X_test_lstm), np.array(y_test_lstm)

# 定義LSTM模型
model = Sequential()
model.add(LSTM(units=50, return_sequences=True, input_shape=(X_train_lstm.shape[1], X_train_lstm.shape[2])))
model.add(Dropout(0.2))
model.add(LSTM(units=50))
model.add(Dropout(0.2))
model.add(Dense(units=1, activation='sigmoid'))
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# 訓練模型 (沒有驗證資料)
history = model.fit(X_train_lstm, y_train_lstm, epochs=100, batch_size=128)

# 評估模型效果
train_loss, train_accuracy = model.evaluate(X_train_lstm, y_train_lstm, verbose=0)
test_loss, test_accuracy = model.evaluate(X_test_lstm, y_test_lstm, verbose=0)

print(f"Training Loss: {train_loss:.4f}, Training Accuracy: {train_accuracy:.4f}")
print(f"Test Loss: {test_loss:.4f}, Test Accuracy: {test_accuracy:.4f}")

# 可視化訓練準確性
epochs = range(1, len(history.history['accuracy']) + 1)
plt.plot(epochs, history.history['accuracy'], 'bo', label='Training accuracy')
plt.title('Training Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

# 預測測試資料
predicted_win_rates = model.predict(X_test_lstm)
game_win_rates = {}

# 創建空的 DataFrame 來存儲結果
results_df = pd.DataFrame(columns=['game', 'team', 'actual_winner', 'predict_winner', 'Correct_Prediction'])

for i in range(0, len(predicted_win_rates) - 1, 2):
    game = test_df.iloc[i]['game']
    team1 = test_df.iloc[i]['team']
    team2 = test_df.iloc[i+1]['team']

    team1_rate = predicted_win_rates[i][0]
    team2_rate = predicted_win_rates[i+1][0]

    # 因为总和需要为1，所以进行标准化
    total = team1_rate + team2_rate
    team1_rate /= total
    team2_rate /= total

    game_win_rates[game] = {
        team1: team1_rate,
        team2: team2_rate
    }

    # 根據預測的勝率來確定贏家
    predict_winner1 = 1 if team1_rate > team2_rate else 0
    predict_winner2 = 1 - predict_winner1

    actual_winner1 = test_df.iloc[i]['winner']
    actual_winner2 = test_df.iloc[i+1]['winner']

    correct_prediction1 = 1 if actual_winner1 == predict_winner1 else 0
    correct_prediction2 = 1 if actual_winner2 == predict_winner2 else 0

    results_df = results_df.append({'game': game, 'team': team1, 'actual_winner': actual_winner1, 'predict_winner': predict_winner1, 'Correct_Prediction': correct_prediction1},
                                   ignore_index=True)
    results_df = results_df.append({'game': game, 'team': team2, 'actual_winner': actual_winner2, 'predict_winner': predict_winner2, 'Correct_Prediction': correct_prediction2},
                                   ignore_index=True)

# 計算預測和實際的正確率
accuracy = results_df['Correct_Prediction'].mean() * 100

# 印出最終結果
print(results_df)
print(f"Prediction Accuracy: {accuracy:.2f}%")

# 從final_test_df中提取特徵
features = ['attack_rate', 'block_rate', 'serve_rate', 'receive_rate', 'dig_rate', 'set_rate', 'team_wins', 'team_losses']
X_test = final_test_df[features].values
X_test = scaler.transform(X_test)  # 使用之前的scaler進行歸一化

# 根據LSTM的輸入格式重塑資料
X_test_lstm = []
for i in range(time_steps, len(X_test)):
    X_test_lstm.append(X_test[i-time_steps:i])
X_test_lstm = np.array(X_test_lstm)
predicted_win_rates = model.predict(X_test_lstm)
game_win_rates = {}

for i in range(0, len(predicted_win_rates) - 1, 2):
    game = final_test_df.iloc[i]['game']
    team1 = final_test_df.iloc[i]['team']
    team2 = final_test_df.iloc[i+1]['team']

    team1_rate = predicted_win_rates[i][0]
    team2_rate = predicted_win_rates[i+1][0]

    # 因为总和需要为1，所以进行标准化
    total = team1_rate + team2_rate
    team1_rate /= total
    team2_rate /= total

    game_win_rates[game] = {
        team1: team1_rate,
        team2: team2_rate
    }

    print(f"Processing game: {game}, Teams: {team1} vs {team2}")
    print(f"Predicted win rates: {team1}: {team1_rate:.4f}, {team2}: {team2_rate:.4f}")

import pandas as pd

# 初始化一個空的列表來保存每場比賽的資料
data = []

for game, rates in game_win_rates.items():
    # 提取隊伍和其對應的勝率
    teams = list(rates.keys())
    rates = list(rates.values())

    # 添加到列表中
    data.append([game, teams[0], rates[0], teams[1], rates[1]])

# 創建一個DataFrame
df_predicted = pd.DataFrame(data, columns=['game', 'team1', 'winRate_Team1', 'team2', 'winRate_Team2'])

# 假設您預測輸出的DataFrame名稱為df_predicted

# 用來儲存新格式的資料
new_data = []

for index, row in df_predicted.iterrows():
    # 判斷哪一隊是贏家
    winner = 0 if row['winRate_Team1'] > row['winRate_Team2'] else 1
    new_data.append([row['game'], row['team1'], row['winRate_Team1'], 1 -winner])
    new_data.append([row['game'], row['team2'], row['winRate_Team2'],  winner])  # 由於輸家為1，贏家為0，所以用1減去winner

# 轉換成新的DataFrame
df_new_format = pd.DataFrame(new_data, columns=['game', 'team', 'winrate', 'winner'])

print(df_new_format)

# 使用left join合併，以df_new_format的game為主
merged_df = pd.merge(df_new_format, final_test_df, on=['game', 'team'], how='left')

# 重新命名欄位
merged_df.rename(columns={'winner_x': 'actual_winner', 'winner_y': 'predict_winner'}, inplace=True)

# 比較實際的勝者和預測的勝者，判斷它們是否一致
merged_df['Correct_Prediction'] = np.where(merged_df['actual_winner'] == merged_df['predict_winner'], 1, 0)

# 移除重複記錄
merged_df_cleaned = merged_df.drop_duplicates(subset=['game', 'team'], keep='first')

# 重新計算預測準確率
accuracy = merged_df_cleaned['Correct_Prediction'].sum() / len(merged_df_cleaned) * 100

final=merged_df_cleaned[['game', 'team', 'actual_winner', 'predict_winner', 'Correct_Prediction']]
print(final)
print(f"Prediction Accuracy: {accuracy:.2f}%")

import matplotlib.font_manager as fm

font_path = 'NotoSansTC-Black.otf'
font_prop = fm.FontProperties(fname=font_path)

import ipywidgets as widgets
import matplotlib
from IPython.display import display, clear_output, Image
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.font_manager as fm

font_path = 'NotoSansTC-Black.otf'
font_prop = fm.FontProperties(fname=font_path)

TEAMS = {
    1: "屏東台電",
    2: "雲林美津濃",
    3: "台中太陽神",
    4: "conti",
    5: "桃園台產",
    6: "連莊"
}

class PredictiveGUI:
    def __init__(self, model):
      self.model = model

      # Create widgets
      self.team_label = widgets.Label(value="Select teams:")
      self.team1_dropdown = widgets.Dropdown(options=TEAMS.values(), description='Team 1:', disabled=False)
      self.team2_dropdown = widgets.Dropdown(options=TEAMS.values(), description='Team 2:', disabled=False)

      self.predict_btn = widgets.Button(description="Predict Winner")
      self.predict_btn.on_click(self.predict_winner)

      self.result_label = widgets.Label(value="")
      self.graph_output = widgets.Output()  # An output widget to display matplotlib plots

      display(self.team_label, self.team1_dropdown, self.team2_dropdown, self.predict_btn, self.result_label, self.graph_output)

    def predict_winner(self, b):
        team1 = self.team1_dropdown.value
        team2 = self.team2_dropdown.value

        # Generate win rates such that they sum up to 1
        team1_win_rate = np.random.rand()
        team2_win_rate = 1 - team1_win_rate

        # Display results
        result = f"{team1}: {team1_win_rate*100:.2f}% win rate, {team2}: {team2_win_rate*100:.2f}% win rate"
        self.result_label.value = result

        # Plotting
        self.plot_win_rates(team1, team1_win_rate, team2, team2_win_rate)

    def plot_win_rates(self, team1, team1_win_rate, team2, team2_win_rate):
        with self.graph_output:
            clear_output(wait=True)  # Clear the previous plot

            labels = [team1, team2]
            win_rates = [team1_win_rate, team2_win_rate]
            bars = plt.bar(labels, win_rates, color=['blue', 'red'])

            for bar in bars:
                yval = bar.get_height()
                plt.text(bar.get_x() + bar.get_width()/2, yval + 0.01, round(yval, 2), ha='center', va='bottom', fontproperties=font_prop)

            plt.xlabel('Teams', fontproperties=font_prop)
            plt.ylabel('Win Rate', fontproperties=font_prop)
            plt.title('Team Win Rates', fontproperties=font_prop)
            plt.xticks(fontproperties=font_prop)
            plt.ylim(0, 1.1)
            plt.show()

app = PredictiveGUI(None)